 Python’s while loop supports indefinite iteration, whereas for loop supports definite iteration
 Iterators take responsibility for:
   - Returning the data from a stream or container one item at a time
   - Keeping track of the current and visited items
 Iterator Protocol implements two methods:
   - .__iter__()	Initializes the iterator and by returning an iterator object. def __iter__(self): return self
   - .__next__()	Iterates over the iterator by returning the next value in the data stream or
   raises Exception(StopIteration) at the end.

 for loops, comprehensions, iterable unpacking ...
 Iterators may be generated by processed or raw input or from no input at all

 Iterators constraints:
 Iterators cannot be iterated more than once.
 Exhausted iterators cannot be reset
 Iterators cannot go backwards as they lack a .__prev__() method
 No. of items cannot be known until it has been exhausted.

 An iterable is an object that you can iterate over, typically, by means of a for loop,
 unpacking operations and in built-in functions, such as
 all(), any(), enumerate(), max(), min(), len(), zip(), sum(), map(), and filter().
 Pure iterable objects typically hold the data themselves. For example, Python built-in container types
 —such as lists, tuples, dictionaries, and sets—are iterable objects. However,
 iterators are also iterable objects even if they don’t hold the data themselves.

 iterables:
  - Implement the iterable protocol
  - Make the built-in iter() function return an iterator
  - Implement the sequence protocol


 Sequences are container data types that store items in consecutive order and, thus, accessible through a zero-based index
 the sequence protocol consists of the following methods:
 .__getitem__(index) takes an integer index starting from zero and returns its corresponding item if
 	index is in range else raises an IndexError exception
 .__len__() returns the length of the sequence.

 uses of iterables: for loops, comprehensions, unpacking

 In sum:  all iterators are iterables because they meet the iterable protocol.
 However, not all iterables are iterators—only those implementing the .__next__() method.
 you can’t use pure iterables as arguments to the next() function.

Another difference has to do with the underlying data. Pure iterables typically hold the data themselves.
In contrast, iterators don’t hold the data but produce it one item at a time, depending on the caller’s demand.
Therefore, iterators are more efficient than iterables in terms of memory consumption.

 !!
 You may feel tempted to add a .__next__() method to a custom iterable.
 This addition will make it an iterable and an iterator at the same time.
 However, this practice isn’t recommended because it prevents multiple iterations over the underlying data.

I = Iterator; i = Iterable
I	i	Feature
✅	✅	Can be used in 'for' loops directly
❌	✅	Can be iterated over many times
✅	✅	Support the 'iter()' function
✅	❌	Support the 'next()' function
✅	❌	Keep information about the state of iteration
✅	❌	Optimize memory use

In general, when dealing with huge datasets, you should take advantage of iterators and write memory-efficient code.
In contrast, if you’re coding custom container or collection classes, then provide them with the iterable protocol
so that you can use them later in for loops.

asynchronous iterators implement the asynchronous iterator protocol, which consists of two methods:
.__aiter__() returns an asynchronous iterator, typically self.
.__anext__() must return an awaitable object from a stream. It must raise a StopAsyncIteration


By definition, iterables support the iterator protocol, which specifies how object members are returned when an object is used in an iterator. Python has two commonly used types of iterables:
- Sequences
- Generators