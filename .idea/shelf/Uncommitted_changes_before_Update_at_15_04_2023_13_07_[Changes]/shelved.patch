Index: n00_concepts.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+> Python’s while loop supports indefinite iteration, whereas for loop supports definite iteration\r\n Iterators take responsibility for:\r\n   - Returning the data from a stream or container one item at a time\r\n   - Keeping track of the current and visited items\r\n Iterator Protocol implements two methods:\r\n   - .__iter__()\tInitializes the iterator and by returning an iterator object. def __iter__(self): return self\r\n   - .__next__()\tIterates over the iterator by returning the next value in the data stream or\r\n   raises Exception(StopIteration) at the end.\r\n\r\n for loops, comprehensions, iterable unpacking ...\r\n Iterators may be generated by processed or raw input or from no input at all\r\n\r\n Iterators constraints:\r\n Iterators cannot be iterated more than once.\r\n Exhausted iterators cannot be reset\r\n Iterators cannot go backwards as they lack a .__prev__() method\r\n No. of items cannot be known until it has been exhausted.\r\n\r\n An iterable is an object that you can iterate over, typically, by means of a for loop,\r\n unpacking operations and in built-in functions, such as\r\n all(), any(), enumerate(), max(), min(), len(), zip(), sum(), map(), and filter().\r\n Pure iterable objects typically hold the data themselves. For example, Python built-in container types\r\n —such as lists, tuples, dictionaries, and sets—are iterable objects. However,\r\n iterators are also iterable objects even if they don’t hold the data themselves.\r\n\r\n iterables:\r\n  - Implement the iterable protocol\r\n  - Make the built-in iter() function return an iterator\r\n  - Implement the sequence protocol\r\n\r\n\r\n Sequences are container data types that store items in consecutive order and, thus, accessible through a zero-based index\r\n the sequence protocol consists of the following methods:\r\n .__getitem__(index) takes an integer index starting from zero and returns its corresponding item if\r\n \tindex is in range else raises an IndexError exception\r\n .__len__() returns the length of the sequence.\r\n\r\n uses of iterables: for loops, comprehensions, unpacking\r\n\r\n In sum:  all iterators are iterables because they meet the iterable protocol.\r\n However, not all iterables are iterators—only those implementing the .__next__() method.\r\n you can’t use pure iterables as arguments to the next() function.\r\n\r\nAnother difference has to do with the underlying data. Pure iterables typically hold the data themselves.\r\nIn contrast, iterators don’t hold the data but produce it one item at a time, depending on the caller’s demand.\r\nTherefore, iterators are more efficient than iterables in terms of memory consumption.\r\n\r\n !!\r\n You may feel tempted to add a .__next__() method to a custom iterable.\r\n This addition will make it an iterable and an iterator at the same time.\r\n However, this practice isn’t recommended because it prevents multiple iterations over the underlying data.\r\n\r\nI = Iterator; i = Iterable\r\nI\ti\tFeature\r\n✅\t✅\tCan be used in 'for' loops directly\r\n❌\t✅\tCan be iterated over many times\r\n✅\t✅\tSupport the 'iter()' function\r\n✅\t❌\tSupport the 'next()' function\r\n✅\t❌\tKeep information about the state of iteration\r\n✅\t❌\tOptimize memory use\r\n\r\nIn general, when dealing with huge datasets, you should take advantage of iterators and write memory-efficient code.\r\nIn contrast, if you’re coding custom container or collection classes, then provide them with the iterable protocol\r\nso that you can use them later in for loops.\r\n\r\nasynchronous iterators implement the asynchronous iterator protocol, which consists of two methods:\r\n.__aiter__() returns an asynchronous iterator, typically self.\r\n.__anext__() must return an awaitable object from a stream. It must raise a StopAsyncIteration\r\n\r\n\r\nBy definition, iterables support the iterator protocol, which specifies how object members are returned when an object is used in an iterator. Python has two commonly used types of iterables:\r\n- Sequences\r\n- Generators\r\n\r\n\r\n--------------------------------------------------\r\nCOP: Control Oriented: Concentrates on actions imperative procedural  -- STRUCTURED PROCEDURAL?\r\nDOP: Data Oriented: Concentrates on data (& methods)    -- LAZY EVALUATIONS?\r\n  - data flows: pass, hide & share\r\n  - data space: store space access\r\nOOP: Object Oriented: Concentrates on Class & objects: integrates actions & data; simulates interacting systems\r\nSOP State Oriented: Concentrates on States and transitions between them -- Automata-based programming?\r\n  * elements\r\n    - Input (a switch)\r\n    - Output (a light bulb)\r\n    - Actions (flip switch)\r\n    - States Q: (On, Off)\r\n        - initial state: q₀ ∈ Q\r\n        - acepting final states set: F ⊆ Q\r\n  * automata types\r\n    - finite: a deteministic finite automata\r\n        * give rise to regular languages; app: pattern recognition -> equivalent to regex\r\n    - push-down\r\n        * give rise to contex-free language; app: parsing\r\n    - Turing machine\r\n        * yield recursively enumerable language; app: general computation\r\n  * Concepts\r\n    - Alphabet Σ: finite set of symbols\r\n    - Language: set of strings over an alphabet\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/n00_concepts.txt b/n00_concepts.txt
--- a/n00_concepts.txt	(revision 70bec149a5af3abe8035ff1704b496555837fce9)
+++ b/n00_concepts.txt	(date 1681505529981)
@@ -85,8 +85,10 @@
     - Output (a light bulb)
     - Actions (flip switch)
     - States Q: (On, Off)
-        - initial state: q₀ ∈ Q
-        - acepting final states set: F ⊆ Q
+        - initial state: q₀ ∈ Q (Anfangszustand)
+        - acepting final states set: F ⊆ Q (Endzustände)
+    - Eingabealphabet Σ
+    - Überbangsfunction δ = QxΣ-->Q
   * automata types
     - finite: a deteministic finite automata
         * give rise to regular languages; app: pattern recognition -> equivalent to regex
@@ -98,5 +100,24 @@
     - Alphabet Σ: finite set of symbols
     - Language: set of strings over an alphabet
 
+Automat = (Q, Σ, δ, q₀, F)
+Übergangsdiagramm
+Tabelle
+Deterministischer endlicher Automat (DEA) vs nicht deterministisches endliche Automat (NEA)
+Ein NEA macht das gleiche wie ein DEA, aber ist nicht deterministisch, dass heißt
+er kann mehrere wege gehen um in ein endzustand zu kommen.
+Potenzmengenkonstruktion wird ein NEA zu DEA machen
+Die ε-Übergänge sind unsere Joker, die wir jederzeit einsetzen dürfen um in einen anderen Zustand zu wechseln.
 
+Regulärer Ausdruck
+Operationen
+- ODER (Alternative) 0+1, 0|1
+- UND (Verkettung) 0·1, 01
+- Wiederhollung 1*
 
+Gesetze zur vereinfachung
+ - Kommutativgesetz: (R+S)=(S+R)
+ - Distributivgesetze: R(S+T)=RS+RT; (S+T)R=SR+TR
+ - Geserte über Kleene-Stern: (R*)* = R*; ∅*=? ε*=ε
+ - Neutrale Elemente: ∅+R=R+∅=R; εR=Rε=R
+ - Absorption: ∅R=R∅=∅
Index: d20_projects/to_romans.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\ndef to_romans(num):\r\n\tmagnitud_order = 0\r\n\toutput_substr = ''\r\n\toutput = ''\r\n\tchars = ('IV', 'XL', 'CD', 'M-')\r\n\twhile num:\r\n\t\tfive_multiple, one_multiple = divmod(num, 5)\r\n\t\tnum, five_multiple = divmod(five_multiple, 2)\r\n\t\tif one_multiple == 4:\r\n\t\t\toutput_substr += chars[magnitud_order][0] # added substractor\r\n\t\t\tif five_multiple:\r\n\t\t\t\toutput_substr += chars[magnitud_order + 1][0] # ends in 9\r\n\t\t\telse:\r\n\t\t\t\toutput_substr += chars[magnitud_order][1] # ends in 4\r\n\t\telse:\r\n\t\t\tif five_multiple:\r\n\t\t\t\toutput_substr += chars[magnitud_order][1]\r\n\t\t\toutput_substr += chars[magnitud_order][0] * one_multiple\r\n\t\tmagnitud_order += 1\r\n\t\toutput = output_substr + output\r\n\t\toutput_substr = ''\r\n\treturn output\r\n#\treturn ''.join(output.reverse())\r\n\r\nfor i in range(500, 4001, 250):\r\n\tprint(to_romans(i), end=' ')
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/d20_projects/to_romans.py b/d20_projects/to_romans.py
--- a/d20_projects/to_romans.py	(revision 70bec149a5af3abe8035ff1704b496555837fce9)
+++ b/d20_projects/to_romans.py	(date 1681556731142)
@@ -4,6 +4,7 @@
 	output_substr = ''
 	output = ''
 	chars = ('IV', 'XL', 'CD', 'M-')
+
 	while num:
 		five_multiple, one_multiple = divmod(num, 5)
 		num, five_multiple = divmod(five_multiple, 2)
@@ -21,7 +22,6 @@
 		output = output_substr + output
 		output_substr = ''
 	return output
-#	return ''.join(output.reverse())
 
-for i in range(500, 4001, 250):
+for i in range(500, 3999, 250):
 	print(to_romans(i), end=' ')
\ No newline at end of file
Index: d06_imperative_procedural/n03_closures.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>power_factory = lambda exp: lambda base: base ** exp\r\n\r\nprint(power_factory(2)(10), power_factory(3)(10), power_factory(2)(15))\r\n\r\n# Variables like exp are called free variables.\r\n# They are variables that are used in a code block but not defined there.\r\n# Free variables are the mechanism that closures use to retain state information between calls.\r\n\r\ndef mean():\r\n\titerable_sum = 0\r\n\tcounter = 0\r\n\tdef inner_mean(number):\r\n\t\tnonlocal iterable_sum\r\n\t\tnonlocal counter\r\n\t\titerable_sum += number\r\n\t\tcounter += 1\r\n\t\treturn iterable_sum/counter\r\n\treturn inner_mean\r\n\r\ncurrent_mean = mean()\r\nanother_mean = mean()\r\nprint( current_mean(10), current_mean(15), 'a', another_mean(1),  another_mean(7), 'a', current_mean(12),\r\n\t\t\t'a', another_mean(4), current_mean(11), current_mean(13) )\r\n#> 10.0 12.5 a 1.0 4.0 a 12.333333333333334 a 4.0 12.0 12.2\r\n\r\n# def dowhile():\r\n# \t\"\"\"Returns a function with a bool parameter returning True the first time and the parameter value after that.\"\"\"\r\n# \tcheck_first_time = True\r\n# \tdef inner_dowhile(condition):\r\n# \t\tnonlocal check_first_time\r\n# \t\tif check_first_time:\r\n# \t\t\tcheck_first_time = False\r\n# \t\t\treturn True\r\n# \t\treturn condition\r\n# \treturn inner_dowhile\r\n#\r\n#\r\n# secret_word = \"python\"\r\n# counter = 0\r\n# word = secret_word\r\n# dowhile_here = dowhile()\r\n# while dowhile_here(word != secret_word):\r\n# \tword = input(\"Enter the secret word: \").lower()\r\n# \tcounter = counter + 1\r\n# \tif word == secret_word:\r\n# \t\tprint('succeed!')\r\n# \t\tbreak\r\n# \tif counter > 7:\r\n# \t\tprint('too many tries!')\r\n# \t\tbreak\r\n#\r\n# print('hola')\r\n#\r\n# secret_word = \"hola\"\r\n# counter = 0\r\n# word = secret_word\r\n# dowhile_here = dowhile()\r\n# while dowhile_here(word != secret_word):\r\n# \tword = input(\"Enter the secret word: \").lower()\r\n# \tcounter = counter + 1\r\n# \tif word == secret_word:\r\n# \t\tprint('succeed!')\r\n# \t\tbreak\r\n# \tif counter > 7:\r\n# \t\tprint('too many tries!')\r\n# \t\tbreak\r\n\r\ndef generator():\r\n\tcount = 0\r\n\tdef inner_generator():\r\n\t\tnonlocal count\r\n\t\tcount +=1\r\n\t\treturn count\r\n\treturn inner_generator\r\n\r\ngenerator1 = generator()\r\ngenerator1()\r\ngenerator1()\r\ngenerator1()\r\ngenerator1()\r\ngenerator1()\r\nprint(generator1())\r\n\r\nprint((generator1() for _ in range(5)))
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/d06_imperative_procedural/n03_closures.py b/d06_imperative_procedural/n03_closures.py
--- a/d06_imperative_procedural/n03_closures.py	(revision 70bec149a5af3abe8035ff1704b496555837fce9)
+++ b/d06_imperative_procedural/n03_closures.py	(date 1681513058513)
@@ -81,4 +81,8 @@
 generator1()
 print(generator1())
 
-print((generator1() for _ in range(5)))
\ No newline at end of file
+print((generator1() for _ in range(5)))
+
+from functools import partial
+square = partial(lambda exp, base: base ** exp, 2)
+print(square(10))
\ No newline at end of file
Index: d09_imperative_oop/dataclases.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/d09_imperative_oop/dataclases.py b/d09_imperative_oop/dataclases.py
new file mode 100644
--- /dev/null	(date 1681555433989)
+++ b/d09_imperative_oop/dataclases.py	(date 1681555433989)
@@ -0,0 +1,143 @@
+from dataclasses import dataclass, make_dataclass, field, fields
+from math import asin, cos, radians, sin, sqrt
+from typing import List, Any
+
+import sys
+sys.path.append('../d02_iterables_and_iterators/')
+from constant_colors_emph import RED, RESET, code_str
+
+
+@dataclass
+class InventoryItem:
+	"""Class for keeping track of an item in inventory."""
+	name: str
+	unit_price: float
+	quantity_on_hand: int = 0
+
+	def total_cost(self) -> float:
+		return self.unit_price * self.quantity_on_hand
+
+#=========================================================================================================
+
+# latitude +-90N/S, Longitude +-180EW
+
+Coordinate = make_dataclass('Coordinate', ['name', 'latitude_sn_deg', 'longitude_we_deg']) # eq to following
+
+@dataclass
+class Coordinate:
+	name: str
+	latitude_sn_deg: float = .0
+	longitude_we_deg: float = .0
+
+
+	def distance_to(self, other):
+		earth_radius_km = 6371
+		sinsq = lambda z: (sin(radians(z))) ** 2
+		cos_deg = lambda z: cos(radians(z))
+
+		radicand = sinsq((other.latitude_sn_deg  - self.latitude_sn_deg)  / 2) + \
+							 sinsq((other.longitude_we_deg - self.longitude_we_deg) / 2) * \
+				       cos_deg(other.latitude_sn_deg) * cos_deg(self.latitude_sn_deg)
+
+		return 2 * earth_radius_km * asin(sqrt(radicand))
+
+# oslo = Coordinate('Oslo', 59.9, 10.8)
+# vancouver = Coordinate('Vancouver', 49.3, -123.1)
+# print(f'{oslo.name} is at {oslo.latitude_sn_deg}°N, {oslo.longitude_we_deg}°E')
+# print(f'{oslo.distance_to(vancouver)=}')
+
+# The field() specifier is used to customize each field of a data class individually.
+# For reference, these are the parameters field() supports:
+# -	default: Default value of the field
+# -	default_factory: Function that returns the initial value of the field
+# -	init: Use field in .__init__() method? (Default is True.)
+# -	repr: Use field in repr of the object? (Default is True.)
+# -	compare: Include the field in comparisons? (Default is True.)
+# -	hash: Include the field when calculating hash()? (Default is to use the same as for compare.)
+# -	metadata: A mapping with information about the field
+
+@dataclass
+class Position:
+	name: str
+	lat: float = field(default=0.0, metadata={'unit': 'degrees', 'term': 'latitude'})
+	lon: float = field(default=0.0, metadata={'unit': 'degrees', 'term': 'longitude'})
+
+
+lat_unit = fields(Position)[2].metadata['unit']
+for each_field in fields(Position):
+	print()
+	for each_subfield in ((str(each_field))[6:-1]).replace('=', ':\t').split(','):
+		print(each_subfield)
+
+#========================================================================================================
+
+@dataclass
+class WithoutExplicitTypes:
+	name: Any
+	value: Any = 42
+
+# @dataclass() decorator in parentheses. The following parameters are supported:
+#  - init: Add .__init__() method? (Default is True.)
+#  - repr: Add .__repr__() method? (Default is True.)
+#  - eq: Add .__eq__() method? (Default is True.)
+#  - order: Add ordering methods? (Default is False.)
+#  - unsafe_hash: Force the addition of a .__hash__() method? (Default is False.)
+#  - frozen: If True, assigning to fields raise an exception. (Default is False.)
+
+@dataclass(order=True)
+class PlayingCard:
+	rank: str
+	suit: str
+
+	def __str__(self):
+		to_str = self.rank + self.suit
+		if self.suit == '♥' or self.suit == '♦' or self.rank == '_':
+			to_str = to_str.join([code_str(RED), code_str(RESET)])
+		return to_str
+
+	# def __repr__(self):
+	# 	suit_to_str = self.suit if self.suit == '♣' or self.suit == '♠' else chr(ord(self.suit) - 4)
+	# 	return suit_to_str + self.rank
+
+
+#  In general, a Python object has two different string representations:
+#  - repr(obj) is defined by obj.__repr__() and should return a developer-friendly representation of obj.
+# 	If possible, this should be a code that can recreate obj. Data classes do this.
+#  - str(obj) is defined by obj.__str__() and should return a user-friendly representation of obj.
+# 	Data classes do not implement a .__str__() method, so Python will fall back to the .__repr__() method.
+
+
+def make_french_deck():
+	return [
+		PlayingCard(i_rank, i_suit)
+		for i_suit in '♥♦♣♠'
+		for i_rank in 'A23456789XJQK'
+	] + [PlayingCard('-', '𝓙')] * 2 + [PlayingCard('_', '𝓙')]
+
+@dataclass
+class Deck:
+	cards: List[PlayingCard] = field(default_factory=make_french_deck)
+
+	def __repr__(self):
+		cards = ', '.join(f'{c!s}' for c in self.cards)
+		return f'{self.__class__.__name__}({cards})'
+
+
+for card_index, each_card in enumerate(Deck().cards):
+	print('\n' if not card_index % 13 else '', each_card, end=' ')
+print('\n')
+
+print(Deck())
+
+for card_index, each_card in enumerate(Deck().cards):
+	print('\n' if not card_index % 13 else '', each_card, end=' ')
+print('\n')
+
+queen_of_hearts = PlayingCard('Q', '♥')
+ace_of_spades = PlayingCard('A', '♠')
+joker = PlayingCard('-', '𝓙')
+two_cards = Deck([queen_of_hearts, ace_of_spades])
+
+
+
+
